
<!-- GUN is a graph data base -->
<!-- SEA is a cryptographic security library for GUN -->
<!-- WebRTC enables P2P connections to other browsers -->

<html>
    <head>
    </head>
    <body>
        <h1>Todo</h1>

        <form id="sign">
            <input id="alias" placeholder="username">
            <input id="pass" type="password" placeholder="passphrase">
            <input id="in" type="submit" value="sign in">
            <input id="up" type="button" value="sign up">
        </form>

    <ul></ul>

    <form id="said">
        <input id="say">
        <input id="speak" type="submit" value="speak">
    </form>

    <script src="https://cdn.jsdelivr.net/npm/gun/examples/jquery.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
    <!-- script src="https://cdn.jsdelivr.net/npm/gun/lib/webrtc.js"></script -->
    <script>
        /* --- LEGACY SECURITY REQUIREMENT ---
        * 
                * For legacy security reasons, Browsers, Internet Firewalls, and WebRTC
                * wont let me directly connect to other machines unless they have a
                * publicly accessible IP address. To get around this WebRTC uses public
                * "signaling servers" to coordinate where non-IPv6 peers (like a brower)
                * are and then attempts to establish a P2P connection.
                *
        */

        var gun = Gun(['http://localhost:8765/gun', 'https://gun-manhattan.herokuapp.com/gun']);

        /* --- P2P COMMUNICATION ---
        *
                * GUN uses "relay peers" to automatically perform the function of a "signaling server"
                * they can also be fully decentralized. Even if a direct connection is not formed
                * to the ideal peer, DAM (Daisy-chain Ad-hoc Mesh-network) is able to relay
                * messages to indirect peers. (DAM is a networking algorithm.)
                * 
                * Heroku is used for deployment.
                *
        */

        /* --- RUN GUN LOCALLY ---
                *
                * Run GUN locally with a npm package. Execute "npm start" in the gun module directory.
                * 
                */

        /* --- DATA STORAGE ---
                *
                * Some blockchain like enviroments require their peers to store all shared data
                * but GUN peers can get away with only storing some of the shared data.
                *
                * Data for browers is stored in localStorage by default but an indexedDB adapter exists using RAD.
                *
                * RAD uses fs to dump to the disk. Other plugins like AWS S3 and more exists as alternatives.
                */

        var user = gun.user();

        // NOTE: Even though our messages to Carl and David
        // could pass through Alice and Bob's machines
        // thanks to User in SEA everything stays secure.

        $('#up').on('click', function(a){
            user.create($('#alias').val(), $(''))
        });

        $('#sign').on('submit', function(e){
            e.preventDefault();
            user.auth($('#alias').val(), $('#pass').val());
        });

        // NOTE: There are some methods which a password can
        // be reset. 3FA (3-Friend Account recovery)

        // It is dangerous for passwords and keys to be in JS
        // Add-ons like Party that have SEA support help.
        // The objective to make browsers work with SEA is
        // refered to as Secure Render.

        // When the user tries to submit a TO-DO
        $('#said').on('submit', function(e){
            e.preventDefault();

            // user.is will falsify if the user is not
            // logged in. Great for redirecting users.
            if (!user.is){ return }
            
            
            // Checkout the Crash Course for more examples
            // of storing values on GUN.
            user.get('said').set($('#say').val());

            $('#say').val("");
        });

        // Helper to update UI
        function UI(say, id){
            var li = $('#' + id).get(0)
                || $('<li>').attr('id', id).appendTo('ul');
            $(li).text(say);
        }

        // Listen for the login event, to hide the login UI.
        gun.on('auth', function(){
            $('#sign').hide();
            user.get('said').map().once(UI);
            // Want to stay signed in?
            // use: user.recall({sessionStorage: true});
        });

        /* --- DATA ACQUISION ---
        *
        * Line 119 is pretty complex. Time for a break down.
        * 
        * First we traverse into the 'said' property from the user node.
        * The user node is our starting point in the graph.
        * 
        * Since the user is a table of items, we grab each item with:
        *       map()
        *
        * Map can do this to the data:
        * - Transform
        * - Filter
        * - Reduce
        * - and more
        *
        * If no function is provided, it operates as a get-each-item.
        *
        * once() gets called with each item, once, per item.
        * in contrast to: on() which is called many times from real-time updates.
        * 
        * When the table is updated with a new item, map will still fire
        * once() with the new item.
        * 
        */
    </script>
    </body>
</html>
